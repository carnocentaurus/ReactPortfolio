// ToDoList.tsx

import {useState, useEffect, useRef, type FC, type ChangeEvent, type MouseEvent} from "react";


const ToDoList: FC = () => {
    const [activeTab, setActiveTab] = useState<string>("PendingTasksTab");

    const [taskInput, setTaskInput] = useState<string>("");
    const [pendingTasks, setPendingTasks] = useState<string>("");
    const [completedTasks, setCompletedTasks] = useState<string>("");
    const [showManageTaskDiv, setShowManageTaskDiv] = useState<boolean>(false);
    const [selectedTaskName, setSelectedTaskName] = useState<string>("");
    const [selectedTaskElement, setSelectedTaskElement] = useState<HTMLLIElement | null>(null);

    const pendingTasksDisplayRef = useRef<HTMLUListElement>(null);
    const completedTasksDisplayRef = useRef<HTMLUListElement>(null);


    // render saved tasks
    useEffect(() => {
        const savedPendingTasks: string | null = localStorage.getItem("PendingTasks");
        const savedCompletedTasks: string | null = localStorage.getItem("CompletedTasks");

        setPendingTasks(savedPendingTasks || "");
        setCompletedTasks(savedCompletedTasks || "");
    }, []); // run this only once when the component first loads


    function getAndFormatDate(): string {
        const now: Date = new Date();

        let currentDate: number | string = now.getDate();
        const currentMonth: number = now.getMonth();
        const currentYear: number = now.getFullYear();

        // prepend 0 if the current date is single digit
        currentDate = currentDate < 10 ? "0" + currentDate : currentDate;

        let hours: string | number = now.getHours();
        let minutes: number | string = now.getMinutes();
        const meridiem: string = hours >= 12 ? "PM" : "AM";

        hours = hours % 12 || 12; // converts 24-hour format to 12-hour format
        hours = hours < 10 ? "0" + hours : hours;
        minutes = minutes < 10 ? "0" + minutes : minutes;

        const formattedTime: string = `${hours}:${minutes} ${meridiem}`;

        const abbrMonthNames: string[] = [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
        ];

        return `${currentDate} ${abbrMonthNames[currentMonth]} ${currentYear} â€¢ ${formattedTime}`;
    }


    function addTask(): void {
    if (!taskInput) {
        alert("Enter task name");
        return;
    }

    const taskName: string = taskInput.trim();
    const dateAdded: string = getAndFormatDate();

    const task = `
        <li>
            <span>${taskName}</span>
            <span>${dateAdded}</span>
            <button>Move Up</button>
            <button>Move Down</button>
        </li>
    `;

    const newPendingTasks: string = pendingTasks + task;
    setPendingTasks(newPendingTasks);
    localStorage.setItem("PendingTasks", newPendingTasks);

    setTaskInput("");
}


    function moveTask(event: MouseEvent<HTMLDivElement>): void {
        const target: HTMLElement = event.target as HTMLElement; // task to move
        const pendingTasksDisplay: HTMLUListElement | null = pendingTasksDisplayRef.current;

        if (!pendingTasksDisplay) return;

        // parent element of the task to move
        const targetTask: HTMLLIElement = target.parentElement as HTMLLIElement;
        const taskIndex: number = Array.from(pendingTasksDisplay.children).indexOf(targetTask);

        if (target.tagName === "LI") {
            setShowManageTaskDiv(true);
            setSelectedTaskElement(target as HTMLLIElement);

            // ? = optional chaining (avoid crash if firstChild is null)
            const taskName: string = (target as HTMLLIElement).firstChild?.textContent || "";
            setSelectedTaskName(taskName);
        }

        if (target.innerText === "Move Up") {
            if (taskIndex === 0) return;

            pendingTasksDisplay.insertBefore(targetTask, targetTask.previousSibling);
            const updatedHTML: string = pendingTasksDisplay.innerHTML;
            setPendingTasks(updatedHTML);
            localStorage.setItem("PendingTasks", updatedHTML);
        }

        if (target.innerText === "Move Down") {
            pendingTasksDisplay.insertBefore(targetTask, targetTask.nextSibling?.nextSibling || null);

            const updatedHTML: string = pendingTasksDisplay.innerHTML;
            setPendingTasks(updatedHTML);
            localStorage.setItem("PendingTasks", updatedHTML);
        }
    }


    function managePendingTask(event: MouseEvent<HTMLDivElement>): void {
        const target: HTMLElement = event.target as HTMLElement;
        const pendingTasksDisplay: HTMLUListElement | null = pendingTasksDisplayRef.current;
        const completedTasksDisplay: HTMLUListElement | null = completedTasksDisplayRef.current;

        if (!pendingTasksDisplay || !completedTasksDisplay || !selectedTaskElement) return;

        if (target.innerText === "Mark as Complete") {
            const confirmComplete: boolean = confirm(`Move ${selectedTaskName} to completed tasks?`);

            if (confirmComplete) {
                alert(`"${selectedTaskName}" has been moved!`);

                const taskName: string = selectedTaskElement.firstChild?.textContent || "";
                const dateCompleted: string = getAndFormatDate();

                const completedTask: string = `
                    <li>
                        ${taskName}
                        <span>${dateCompleted}</span>
                        <button>Delete</button>
                    </li>
                `;

                // existing completed task + new completed task
                const newCompletedTasks: string = completedTasks + completedTask;
                setCompletedTasks(newCompletedTasks);
                localStorage.setItem("CompletedTasks", newCompletedTasks);

                pendingTasksDisplay.removeChild(selectedTaskElement);

                const updatedPendingTasks: string = pendingTasksDisplay.innerHTML;
                setPendingTasks(updatedPendingTasks);
                localStorage.setItem("PendingTasks", updatedPendingTasks);
            }
        }

        if (target.innerText === "Edit") {
            const newTaskName: string | null = prompt("Enter new task name: ");

            if (newTaskName) {
                setSelectedTaskName(newTaskName);
                
                if (selectedTaskElement.firstChild) {
                    selectedTaskElement.firstChild.textContent = newTaskName;

                    const updatedHTML: string = pendingTasksDisplay.innerHTML;
                    setPendingTasks(updatedHTML);
                    localStorage.setItem("PendingTasks", updatedHTML);
                }
            }
        }

        if (target.innerText === "Delete") {
            const confirmDelete: boolean = confirm(
                `Permanently delete "${selectedTaskName}"? This action is irreversible.`
            );

            if (confirmDelete) {
                pendingTasksDisplay.removeChild(selectedTaskElement);

                const updatedHTML: string = pendingTasksDisplay.innerHTML;
                setPendingTasks(updatedHTML);
                localStorage.setItem("PendingTasks", updatedHTML);

                setShowManageTaskDiv(false);
            }
        }

        if (target.innerText === "Go Back") setShowManageTaskDiv(false);
    }


    function manageCompletedTasks(event: MouseEvent<HTMLDivElement>): void {
        const target: HTMLElement = event.target as HTMLElement;
        const completedTasksDisplay: HTMLUListElement | null = completedTasksDisplayRef.current;

        if (!completedTasksDisplay) return;

        if (target.innerText === "Delete") {
            const targetTask: HTMLElement = target.parentElement as HTMLElement;
            const taskName: string = targetTask.previousSibling?.textContent || "";

            const confirmDelete: boolean = confirm(
                `Permanently delete "${taskName}"? this action is irreversible`
            );

            if (confirmDelete) {
                completedTasksDisplay.removeChild(targetTask);

                const updatedHTML: string = completedTasksDisplay.innerHTML;
                setCompletedTasks(updatedHTML);
                localStorage.setItem("CompletedTasks", updatedHTML);
            }
        }
    }


    return(
        <main className="
            scrollbar-hide
            bg-[#f4f4f4]
            rounded-2xl
            text-center
            mt-10 sm:mt-20 lg:mt-10
            py-5 sm:py-10 lg:py-5
            px-9
            w-70 sm:w-115 lg:w-80
            max-w-70 sm:max-w-115
            h-115
            max-h-120 sm:max-h-200 md:max-h-170 lg:max-h-115
            overflow-y-scroll
        ">
            {/* TABS DIV */}
            <div className="
                flex 
                justify-evenly 
                font-poppins 
                border
                border-[#333]
                rounded-full
                bg-[#f4f4f4]
                text-[#333]
                mb-5 sm:mb-10 md:mb-5
                text-base sm:text-2xl lg:text-base
            ">
                <p 
                    onClick={() => setActiveTab("PendingTasksTab")}
                    className={
                        `${activeTab === "PendingTasksTab" ? "bg-[#333] text-[#f4f4f4]" : "bg-[#f4f4f4] text-[#333]"}
                        w-full
                        rounded-full
                        py-0.5
                    `}
                >
                  Pending
                </p>
                
                <p 
                    onClick={() => setActiveTab("CompletedTasksTab")}
                    className={`${activeTab === "CompletedTasksTab" ? "bg-[#333] text-[#f4f4f4]" : "bg-[#f4f4f4] text-[#333]"}
                    w-full
                    rounded-full
                    py-0.5
                `}
                >
                  Complete
                </p>
            </div>

            
            {/* PENDING TASKS DIV */}
            <div
                onClick={moveTask}
                className={`${activeTab === "PendingTasksTab" ? "block" : "hidden"}`}
            >
                {/* NESTED DIV */}
                <div className="flex justify-center">
                    <input
                        value={taskInput}
                        onChange={(event: ChangeEvent<HTMLInputElement>) => setTaskInput(event.target.value)}
                        className="
                            font-poppins
                            text-sm sm:text-2xl lg:text-sm
                            text-[#333]
                            border sm:border-3 lg:border-2
                          border-[#333]
                            w-37 sm:w-60 lg:w-40
                            py-[0.2rem] sm:py-2 lg:py-1
                            px-2 sm:px-3 lg:px-2
                            placeholder:text-sm sm:placeholder:text-2xl lg:placeholder:text-sm
                            placeholder:text-[#666]
                        "
                        placeholder="Enter Task"
                    />
                    <button 
                        onClick={addTask}
                        className="
                            bg-[#333] 
                          text-[#f4f4f4] 
                            font-poppins 
                            text-base sm:text-2xl lg:text-sm
                            px-2 sm:px-3
                        "
                    >
                        Add
                    </button>
                </div>

                <ul ref={pendingTasksDisplayRef} dangerouslySetInnerHTML={{ __html: pendingTasks }}></ul>
            </div>


            {/* MANAGE PENDING TASK DIV */}
            <div
                onClick={managePendingTask}
                className={showManageTaskDiv ? "block" : "hidden"}
            >
                <p>{selectedTaskName}</p>

                <button>Mark as Complete</button>
                <button>Edit</button>
                <button>Delete</button>

                <button>Go Back</button>
            </div>


            {/* COMPLETED TASKS DIV */}
            <div
                onClick={manageCompletedTasks}
                className={showManageTaskDiv || activeTab !== "CompletedTasksTab" ? "hidden" : "block"}
            >
                <ul ref={completedTasksDisplayRef} dangerouslySetInnerHTML={{ __html: completedTasks }}></ul>
            </div>
        </main>
    );
}


export default ToDoList;



explain each line
<Task[]>([]);
<Task | null>(null);
const maxOrder = pendingTasks.length > 0 
            ? Math.max(...pendingTasks.map(t => t.order))
            : -1;
const newTask: Task = {
            id: `task_${Date.now()}_${Math.random()}`,
const index = pendingTasks.findIndex(t => t.id === task.id);
const newTasks = [...pendingTasks];
const tempOrder = newTasks[index].order;
newTasks[index].order = prevTask.order;
prevTask.order = tempOrder;
newTasks.sort((a, b) => a.order - b.order);
const completedTask: Task = {
                ...task,
                date: getAndFormatDate()
            };
const updatedCompletedTasks = [...completedTasks, completedTask];
 const updatedPendingTasks = pendingTasks.filter(t => t.id !== task.id);
 if (newTaskName && newTaskName.trim()) {
            const updatedTasks = pendingTasks.map(t => 
                t.id === task.id ? { ...t, name: newTaskName.trim() } : t
            );

            setPendingTasks(updatedTasks);
            localStorage.setItem("PendingTasks", JSON.stringify(updatedTasks));

            setSelectedTask({ ...task, name: newTaskName.trim() });
        }
what is this nested monstrosity and didnt i say dont add your own styles
<ul className="flex flex-col gap-2">
                    {pendingTasks.map((task) => (
                        <li 
                            key={task.id}
                            className="flex flex-col gap-2 p-4 bg-white rounded-lg border border-[#333]"
                        >
                            <span 
                                onClick={() => {
                                    setSelectedTask(task);
                                    setShowManageTaskDiv(true);
                                }}
                                className="font-medium text-[#333] cursor-pointer"
                            >
                                {task.name}
                            </span>
                            <span className="text-sm text-[#666]">{task.date}</span>
                            
                            <div className="flex gap-2">
                                <button
                                    onClick={() => moveTaskUp(task)}
                                    className="px-3 py-1 text-sm bg-[#f4f4f4] border border-[#333] rounded"
                                >
                                    Move Up
                                </button>
                                <button
                                    onClick={() => moveTaskDown(task)}
                                    className="px-3 py-1 text-sm bg-[#f4f4f4] border border-[#333] rounded"
                                >
                                    Move Down
                                </button>
                            </div>
                        </li>
                    ))}
                </ul>